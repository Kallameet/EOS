% IEEE Paper Template for A4 Page Size (V1)
% Sample Conference Paper using IEEE LaTeX style file for A4 pagesize.
% Copyright (C) 2006-2008 Causal Productions Pty Ltd.
% Permission is granted to distribute and revise this file provided that
% this header remains intact.
%
% REVISION HISTORY
% 20080211 changed some space characters in the title-author block
%
\documentclass[11pt,conference,a4paper]{IEEEtran}
\usepackage{times,amsmath,epsfig}
\include{kommandos}
%
\title{Dalvik VM}
%
\author{%
% author names are typeset in 11pt, which is the default size in the author block
{Reinhard Penn, Sebastian Ratzenb�ck}%
% add some space between author names and affils
\vspace{1.6mm}\\
\fontsize{10}{10}\selectfont\itshape
% 20080211 CAUSAL PRODUCTIONS
% separate superscript on following line from affiliation using narrow space
Embedded Systems Design, FH Oberösterreich\\
Campus Hagenberg\\
\fontsize{9}{9}\selectfont\ttfamily\upshape
%
% 20080211 CAUSAL PRODUCTIONS
% in the following email addresses, separate the superscript from the email address
% using a narrow space \,
% the reason is that Acrobat Reader has an option to auto-detect urls and email
% addresses, and make them 'hot'. Without a narrow space, the superscript is included
% in the email address and corrupts it.
% Also, removed ~ from pre-superscript since it does not seem to serve any purpose
$^{1}$\,S1410567017@students.fh-hagenberg.at\\
$^{3}$\,S1419002063@students.fh-hagenberg.at%
% add some space between email and affil
\vspace{1.2mm}\\
}
%
\begin{document}
\maketitle
%
\begin{abstract}
This paper is about the Dalvik Virtual Machine. The goals are to give a short overview on the Dalvik VM and its function. Furthermore the \member{.dex} file format will be explained. In the end a comparison between the Dalvik VM and the newer Android Runtime will take place.
\end{abstract}

%
\begin{figure}
\centering
\includegraphics[width=0.25\textwidth]{Android_robot}
\caption{Android Logo\cite{6}}
\label{fig:Android_robot}
\end{figure}

\section{Allgemeines\cite{3}}
Bei Dalvik handelt es sich um eine Open Source Software die von Dan Bornstein entwickelt wurde. Benannt ist sie nach einem Fischerdorf in Eyjafj�r�ur, Island. Ver�ffentlicht wurde die Software unter Apache License 2.0. Die Ausf�hrung findet auf einem Linux Kernel statt.
\\
\\
Verwendung findet Dalvik in Googles Betriebssystem Android. Einsatz findet Dalvik hierbei als virtuelle Maschine. Der Hauptverwendungsbereich liegt im Mobilbereich, wie zum Beispiel bei Smartphones, Tablets und seit neuestem auch bei Smart Tvs und Wearables, wie Smartwatches.


\section{Architektur\cite{2}}
In diesem Kapitel wird die Architektur der Dalvik Virtual Machine erkl�rt. Besonderes Augenmerk wird hierbei auf den Aufbau der \member{.dex} Datei gelegt.


\subsection{Funktion}
In Abbildung 2 ist die allgemeine Architektur von Android zu sehen. In ihr sieht man, dass die Dalvik Virtual Machine Teil der Android Runtime ist. In Android bekommt jeder Prozess seine eigene virtuelle Maschine, bei dieser handelt es sich um eine Dalvik VM. Sie �hnelt teilweise einer Java VM. Ein bedeutender Unterschied ist allerdings, dass eine Java VM stapelbasiert und eine Dalvik VM registerbasiert arbeitet. Diese registerbasierte Arbeitsweise lehnt sich an moderne Prozessorarchitekturen an. Sie verarbeitet Registermaschinencode, dadurch wird die Dalivk VM schneller als die Java VM und ist ressourcenschonender.
\\
\begin{figure*}
\centering
\includegraphics[width=0.825\textwidth]{AndroidArchitecture}
\caption{Android Architektur\cite{1}}
\label{fig:AndroidArchitecture}
\end{figure*}
\\
Ein weiterer bedeutender Unterschied liegt darin, dass eine Dalvik VM klassische Java Bibliotheken nicht unterst�tzt, zum Beispiel \member{AWT} und \member{Swing}. Es werden eigene Bibliotheken verwendet, die Apache Harmony als Grundlage verwenden.
\\
\\
Ein wichtiger Bestandteil der \member{SDK} ist das Tool \member{dx}. Es sorgt daf�r, dass Java Bin�rdaten in Dalvik Executables umgewandelt werden. Das hei�t es wandelt \member{.class} Dateien in \member{.dex} Dateien um. Bei dieser Umwandlung k�nnen auch mehrere \member{.class} Dateien zu einer \member{.dex} Datei zusammengefasst werden, beziehungsweise kann der Speicherbedarf, mithilfe von \member{.odex} Dateien optimiert werden. 
\\
\\
In Abbildung 3 ist ein solcher Vorgang beispielhaft dargestellt. Zuerst werden die \member{.java} Dateien in \member{.class} Dateien kompiliert. Nach dem Kompiliervorgang werden die Bin�rdateien und die \member{.class} Dateien mithilfe des \member{dx} Tools zu eienr \member{.dex} Datei konvertiert. Mithilfe dieser Datei kann nun eine \member{.apk} Datei erstellt werden. Bei dieser handelt es sich um die Applikationsdatei mit der, der Endbenutzer die Anwendung auf seinem Mobiltelefon installiert.

\begin{figure*}
\centering
\includegraphics[width=\textwidth]{ClassToDex}
\caption{Android Kompiliervorgang\cite{7}}
\label{fig:ClassToDex}
\end{figure*}


\subsection{.dex Format}
In .dex Dateien werden die Klassen Definitionen und die dazugeh�rigen Daten gespeichert. Es handelt sich dabei um die ausf�hrbaren Dateien der Dalvik VM. Android Programme werden zuerst in Java Bytecode kompiliert. Dieser wird im Anschluss in Dalvik Bytecode �bersetzt. 
\\
\\
In Abbildung 4 ist der Aufbau einer .dex Datei im Vergleich zu einer .class Datei von Java zu sehen. F�r alle folgenden Listen der Datei d�rfen keine doppelten Eintr�ge vorhanden sein.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{DexFileFormat}
\caption{Dex Dateiformat\cite{1}}
\label{fig:DexFileFormat}
\end{figure}

\subsubsection{Header}
In Ausschnitt 1 ist der Header der \member{.dex} Datei zu sehen. Dabei handelt es sich um eine bestimmte Bytefolge die den Start der Datei bestimmt.

\begin{lstlisting}[float,floatplacement=H,caption=Dex Header\cite{2}]
ubyte[8] DEX_FILE_MAGIC = 
{ 0x64 0x65 0x78 0x0a 0x30 0x33 0x35 0x00 } 
= "dex\n035\0"

\end{lstlisting}

\subsubsection{StringIds}
Hierbei handelt es sich um eine Liste aller Strings die in der Datei verwendet werden. Die Liste muss sortiert sein und darf keine doppelten Eintr�ge enthalten. M�gliche Inhalte sind zum Beispiel konstante Strings und Funktionsnamen.

\subsubsection{TypeIds}
Dies ist eine Liste aller verwendeten Typen dieser Datei. Dazu geh�ren Klassen, Arrays, und Primitive Datentypen. Diese Liste ist nach den \member{StringIds} sortiert.

\subsubsection{ProtoIds}
In dieser Liste befinden sich alle Methoden Prototypen, die in \member{.dex} Datei verwendet werden. Die Prototypen sind prim�r anhand ihrer R�ckgabetypen sortiert und danach anhand ihrer Argumente.

\subsubsection{FieldIds}
Diese Liste enth�lt alle Felder die von der \member{.dex} Datei referenziert werden. Diese Liste wird anhand des Feldtypen und Feldnamen sortiert.

\subsubsection{MethodIds}
In der Methoden Liste werden alle von der \member{.dex} Datei referenzierten Methoden aufgelistet. Diese Liste wird nach dem Methodennamen und dem Methodenprototypen sortiert.

\subsubsection{ClassDefs}
In dieser Liste werden die Klassendefinitionen der \member{.dex} Datei angegeben. Die Liste muss so geordnet werden, dass �bergeordnete Klassen und Interfaces vor den davon ableitenden Klassen angef�hrt werden.

\subsubsection{Data}
In dem Data werden zus�tzliche Daten f�r die oben angef�hrten Listen gespeichert. Die verschiedenen Elemente haben verschiedene Alignements und padding bytes werden, wenn notwendig, eingef�gt. Des weiteren befinden sich in diesem Bereich die Daten von statisch verlinkten Dateien. Bei nicht verlinkten Dateien ist dieser Teilbereich leer.


\subsection{Bytecode \& Instruction Format}
Das Modell der Dalvik VM ist an eine echte Architektur angelegt und soll Calling Conventions C ähnlich realisieren. 
Die Dalvik VM ist registerbasiert und ihre Frames bekommen bei der Erstellung eine fixe Größe zugewiesen. Jedes Frame besteht aus einer bestimmten Anzahl an Registern, die von einer Methode aus dem Bytecode Set vorgegeben wird. Zusätzlich beinhaltet das Frame noch alle zusätzlich benötigten Daten, so wie zum Beispiel Program Counter und die \member{.dex} Datei die die Methode beinhaltet.
Für Bitwerte, wie zum Beispiel \member{integer} und Gleitkommazahlen sind Register 32-Bit lang. Für 64-Bit Werte wird mit einem anliegenden Register ein Paar gebildet. Für Registerpaare wird kein Alignement benötigt. Wenn die Register für Objekt Referenzen benutzt werden, dann sind sie groß genug um exakt eine Referenz zu speichern. Bei einem Methodenaufruf werden N Argumente der Methode in den N letzten Registern des Frames der Methode platziert. Größere Argumente benötigen hierbei 2 Register. Methoden einer Instanz bekommen als ersten Parameter zusätzlich eine \member{this} Referenz übergeben.
\\
\\
Instruktionen sind nicht auf Datentypen limitiert, solange sie den Inhalt der Register nicht interpretieren. Ein Beispiel dafür ist der \member{move} Befehl, ihm ist es egal ob er \member{integer} oder \member{floats} verschiebt. Die meisten Instruktionen sind bei ihrer Ausführung auf die ersten 16 Register limitiert und können auf höhere Register nicht zugreifen. Wenn es möglich ist erlauben einige Instruktionen, aber auch Zugriff auf die ersten 256 Register. In einigen Ausnahmefällen wie zum Beispiel einzelnen \member{move} Instruktionen ist es möglich auf Register zwischen 0 und 65535 zuzugreifen.
Unterstützt eine Instruktion das gewünschte Register nicht muss das hohe Register vor der Operation in ein niederes Register kopiert und nach der Operation wieder zurück kopiert werden.
\\
\\
Die Dalvik VM besitzt einige Pseudoinstruktionen, die dazu verwendet werden um Daten mit variabler Länge zu verarbeiten zum Beispiel \member{fill-array-data}. Diese Instruktionen müssen auf 4 Byte aligned sein. Um dieses Ziel zu erreichen werden bei der Generierung der \member{.dex} Datei wenn nötig \member{nop} Instruktionen eingefügt. Wenn die Applikation auf einem System installiert wird können manche Instruktionen, aufgrund von Optimierungen, verändert werden. Damit kann eine schnellere Ausführung am System erreicht werden.
\\
\\
In Abbildung 5 sind einige Beispielinstruktionen der Dalvik VM zu sehen. Die Syntax ist so aufgebaut das zuerst das Ziel- und danach das Quellregister angegeben wird. Manche Opcodes haben Namenserweiterungen um gewisse Eigenschaften anzuzeigen. Zum Beispiel wird bei 64 Bit Opcodes \member{-wide} hinzugefügt und bei typenspezifischen Opcodes wird der Typ hinzugefügt, \member{-char}.
Anhand des \member{move-wide/from16 vAA, vBBBB} Opcodes lassen sich diese Eigenschaften gut erkennen.

\begin{figure}
\centering
\includegraphics[width=0.4\textwidth]{ByteCode}
\caption{Dalvik VM Instruktionen\cite{2}}
\label{fig:ByteCode}
\end{figure}


\section{Android Runtime}

\subsection{Allgemein}

\subsection{Vergleich zu Dalvik VM}

\bibliographystyle{IEEEtran}

\bibliography{IEEEexample}

\end{document}
